一、问题介绍
 给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。

示例：

输入: S = "ADOBECODEBANC", T = "ABC"
输出: "BANC"
说明：

如果 S 中不存这样的子串，则返回空字符串 ""。
如果 S 中存在这样的子串，我们保证它是唯一的答案。


二、思路分析
（1）首先获取目标字符串和已有字符串的长度，并进行非法判断
（2）创建两个数组，用来记录目标字符串和已有字符串指定字符的出现次数
（3）用数组记录相应字符出现的次数
（4）滑动窗口设置
    4.1 将右指针不断右移，直到得到一个包含整个目标字符串的滑动窗口字符串
    4.2 从滑动窗口字符串的左指针开始往右移动，看是否都包含目标字符串
        4.2.1 如果包含，与记录的不可达min值比较并更新min值
        4.2.2 如果不包含，右指针右移，知道再次满足4.1
    4.3 当右指针到达已有字符串最右端，程序结束，返回截取字符串


三、代码
class Solution {
    public String minWindow(String s, String t) {
        int Slen = s.length();
        int Tlen = t.length();
        if(Slen == 0 || Tlen == 0 || Slen < Tlen) {
            return "";
        }
        
        //维护两个数组，记录已有字符串指定字符的出现次数，和目标字符串指定字符的出现次数
        //ASCII表总长128
        int[] Tfeq = new int[128];
        int[] Sfeq = new int[128];

        //将目标字符串指定字符的出现次数记录
        for (int i = 0; i < Tlen; i++) {
            Tfeq[t.charAt(i)]++;
        }

        //分别为左指针，右指针，最小长度(初始值为一定不可达到的长度)
        //已有字符串中目标字符串指定字符的出现总频次以及最小覆盖子串在原字符串中的起始位置
        //count用来记录 指定字符出现的次数 
        //start表示 第一次找到包含目标字符串时的字符串 中的第一个位置
        int left = 0, right = 0, min = Slen + 1, count = 0, start = 0;
        while (right < Slen) {
            char r = s.charAt(right);
            //说明该字符不被目标字符串需要，此时有两种情况
            // 1.循环刚开始，那么直接移动右指针即可，不需要做多余判断
            // 2.循环已经开始一段时间，此处又有两种情况
            //  2.1 上一次条件不满足，已有字符串指定字符出现次数不满足目标字符串指定字符出现次数，那么此时
            //      如果该字符还不被目标字符串需要，就不需要进行多余判断，右指针移动即可
            //  2.2 左指针已经移动完毕，那么此时就相当于循环刚开始，同理直接移动右指针
            if (Tfeq[r] == 0) {
                right++;
                continue;
            }
            //当且仅当已有字符串目标字符出现的次数小于目标字符串字符的出现次数时，count才会+1
            //是为了后续能直接判断已有字符串是否已经包含了目标字符串的所有字符，不需要挨个比对字符出现的次数
            if (Sfeq[r] < Tfeq[r]) {
                count++;
            }
            //已有字符串中目标字符出现的次数+1
            Sfeq[r]++;
            //移动右指针
            right++;
            //当且仅当已有字符串已经包含了所有目标字符串的字符，且出现频次一定大于或等于指定频次
            while (count == Tlen) {
                //当窗口的长度比已有的最短值小时，更改最小值，并记录起始位置
                if (right - left < min) {
                    min = right - left;
                    start = left;
                }
                char l = s.charAt(left);
                //如果左边即将要去掉的字符不被目标字符串需要，那么不需要多余判断，直接可以移动左指针
                if (Tfeq[l] == 0) {
                    left++;
                    continue;
                }
                //如果左边即将要去掉的字符被目标字符串需要，且出现的频次正好等于指定频次，那么如果去掉了这个字符，
                //就不满足覆盖子串的条件，此时要破坏循环条件跳出循环，即控制目标字符串指定字符的出现总频次(count）-1
                if (Sfeq[l] == Tfeq[l]) {
                    count--;
                }
                //已有字符串中目标字符出现的次数-1
                Sfeq[l]--;
                //移动左指针
                left++;
            }
        }
        //如果最小长度还为初始值，说明没有符合条件的子串
        if (min == s.length() + 1) {
            return "";
        }
        //返回的为以记录的起始位置为起点，记录的最短长度为距离的指定字符串中截取的子串
        return s.substring(start, start + min);

    }
}


四、结果分析
执行结果：通过
执行用时：4 ms, 在所有 Java 提交中击败了91.98%的用户
内存消耗：39.8 MB, 在所有 Java 提交中击败了20.00%的用户
